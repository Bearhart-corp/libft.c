Bug 1 – %p sans le préfixe 0x
Bug 2 – %p avec (void *)-1 affiché en -1 au lieu de 0xffffffffffffffff
tu dois toujours caster le void * en type non signé et jamais laisser la représentation signée intervenir.
Bug 3 – Padding de largeur rempli avec des \0 au lieu d’espaces ' '
Bug 4 – Largeur (width) qui boucle à l’infini → TIMEOUT sur %s et %p
Origine probable (très classique) :

Tu calcules pad = width - len dans un type non signé (size_t, unsigned int, etc.).

Quand len > width, width - len underflow → énorme nombre positif → ta boucle de padding (while (pad--)) ne finit jamais.
int pad = width - len;
if (pad < 0)
    pad = 0;
Ou tester explicitement if (width > len) avant de boucler.
Bug 5 – %s + largeur mal géré pour les NULL ((null))
Origine probable :
Tu traites le cas s == NULL en remplaçant par la chaîne (null) mais tu ne recalcules pas correctement la longueur quand tu appliques la largeur.
Bug 6 – %p + largeur : mélange de deux bugs (0x manquant + padding en \0)
Le 0x n’est jamais géré comme partie de la string à aligner/padder ;
du coup même quand tu le rajouteras, il faudra le compter dans la longueur avant de calculer les espaces.
Bug 7 – %p avec NULL et largeur : chaîne correcte mais valeur de retour fausse
Symptôme :
attendu : chaîne [the address is (nil)], len 23
obtenu : exactement la même chaîne, mais retour = 20
Bug 8 – %d / %i + largeur : \0 insérés dans le nombre lui-même
Bug 9 – %d / %i avec INT_MIN mal géré (overflow sur -n)
Pour les 0 a tous les coups j'ai dû confondre 0 avec '0' #chevre

Bug 10 – %d / %i / %p + largeur : TIMEOUT sur certains cas extrêmes
pad = width - len dans un type non signé → underflow → boucle infinie.

Bug 11 – Valeur de retour globalement incorrecte dès qu’il y a largeur / (nil) / padding
