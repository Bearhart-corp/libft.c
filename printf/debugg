Comportement attendu : Lorsqu’une précision de 0 est spécifiée pour un entier, le standard attend que l’affichage du nombre soit supprimé si sa valeur est zéro (aucun chiffre n’est affiché). S’il y a une largeur minimale, celle-ci doit alors être remplie d’espaces. En revanche, pour une valeur non nulle, la précision=0 n’ajoute ni n’enlève de chiffres – le nombre devrait s’afficher normalement (puisque la règle de suppression ne s’applique qu’au nombre 0).

Comportement observé avec ft_printf : Ce contrat n’est pas respecté. Plusieurs tests montrent que :

Pour la valeur 0, ft_printf n’élimine pas l’affichage. Au contraire, il imprime un « 0 » alors qu’il aurait dû afficher une chaîne vide (ou seulement des espaces si une largeur était demandée). Par exemple, ft_printf("%01.0d", 0) devrait afficher un espace (largeur 1, précision 0, valeur 0) mais la sortie obtenue contient “0”. De même sans largeur, ft_printf("%.0d", 0) produit carrément “0” alors que rien n’était attendu (retour 1 au lieu de 0).

Pour une valeur non nulle, ft_printf tend à supprimer à tort tous les chiffres. Les tests ft_printf("%.0d", 420000) ou ft_printf("%.0d", 2) illustrent cela : aucune sortie n’est produite là où le testeur attendait le nombre en toutes lettres. Le retour de ft_printf est 0 au lieu du nombre de caractères du nombre attendu. Dans le cas des négatifs, on voit même que seul le signe « - » est imprimé sans les chiffres qui suivent ("%01.0d", -4 donne “-” au lieu de “-4”). Inversement, un nombre positif peut être remplacé par un seul ‘0’ erroné ("%01.0d", 4 sort “0” au lieu de “4”). En résumé, dès que la précision 0 est activée, ft_printf semble soit ne rien afficher du tout pour les non-zéro, soit afficher un caractère incorrect.

Hypothèse sur la cause : La gestion de la précision 0 dans le code est fautive. Il est probable qu’une condition du type « si précision == 0 alors ne rien afficher » ait été implémentée sans affiner ce cas aux seules valeurs nulles. Autrement dit, ft_printf traite toute valeur avec .0 comme devant être omise, au lieu de n’omettre que le nombre 0. Ceci expliquerait pourquoi des nombres non nuls disparaissent complètement de la sortie. De plus, l’impression isolée d’un signe “-” suggère que le code gère le signe à part puis applique la règle d’omission aux digits même quand il ne le faudrait pas. Il faudra corriger la condition de suppression pour qu’elle ne s’applique qu’au cas particulier du zéro strictement, et s’assurer que même dans ce cas la largeur minimale est respectée en remplissant d’espaces (actuellement, une largeur est parfois sous-utilisée d’un caractère, possiblement parce que ft_printf “prévoit” un digit qui n’est pas imprimé, cf. un test où %-10.u avec 0 n’affiche que 9 espaces au lieu de 10).

Mauvais placement du signe « - » avec le flag 0

Comportement attendu : Lorsque le drapeau 0 est utilisé pour un entier négatif avec une largeur, le signe moins doit apparaître en tête de la chaîne, suivi des zéros de padding. Autrement dit, pour quelque chose comme "%05d", -42, on attend -0042 (signe avant les zéros). Le signe doit toujours précéder les chiffres et tout éventuel padding de zéros.

Comportement observé avec ft_printf : Le signe est imprimé à la mauvaise position, après les zéros de remplissage. Tous les tests négatifs avec flag 0 montrent le moins inséré trop à droite. Par exemple, ft_printf("%030d", -2147483648) devrait produire -000…3648 (30 caractères au total, signe en premier), mais la sortie est 000…-2147483648 avec le - perdu au milieu. De même, sur "%012d", -2147483648, attendu -02147483648, ft_printf donne 0-2147483648. On voit le zéro de padding placé en première position et le signe moins décalé d’un rang vers la droite.

Hypothèse sur la cause : La logique de padding pour les nombres négatifs est mal implémentée, probablement en imprimant d’abord les caractères de remplissage puis le signe. Normalement, le code devrait détecter le signe négatif, l’écrire immédiatement, puis remplir le reste (en ignorant le flag 0 pour les positions du signe). Si ft_printf écrit les zéros en bloc sans gérer le signe en amont, on obtient effectivement le signe inséré après ces zéros. En somme, le drapeau 0 n’est pas concilié avec le signe « - ». Il faudra modifier la fonction d’affichage pour sortir le signe moins avant de traiter le remplissage par des zéros.

Conflit entre le flag 0 et la précision

Comportement attendu : Si une précision est spécifiée pour une conversion numérique, le flag 0 doit être ignoré (selon la convention printf). Le padding de largeur doit alors se faire avec des espaces, puisque la précision gère déjà les zéros significatifs. Par exemple, "%010.5d", 42 — précision 5 signifie qu’on affiche 00042, et largeur 10 oblige à compléter par 5 espaces à gauche (pas des zéros). De plus, la combinaison d’une largeur et d’une précision doit calculer le padding après avoir déterminé la longueur finale du nombre formaté.

Comportement observé avec ft_printf : Ces règles ne sont pas respectées : le flag 0 continue d’agir malgré une précision, causant à la fois un caractère de remplissage inapproprié et des longueurs erronées :

Padding avec de mauvais caractères : On observe que ft_printf utilise des 0 pour remplir la largeur au lieu d’espaces, même quand une précision est fournie. Par exemple, ft_printf("%020.19d", 8000) devrait préfixer le nombre de 1 espace (largeur 20, 19 chiffres significatifs), mais la sortie obtenue commence par un 0 au lieu d’un espace. Autrement dit, le flag 0 n’a pas été désactivé et des zéros de padding subsistent où il aurait fallu des espaces.

Double comptage du padding (sorties trop longues) : Pire, ft_printf semble cumuler le padding de précision et de largeur au lieu de les arbitrer. Ainsi, il ajoute des zéros pour atteindre la précision puis ajoute encore des zéros pour la largeur, donnant beaucoup trop de caractères. Un exemple frappant : "%042.20u", 42000 (largeur 42, précision 20) devrait donner 22 espaces + 20 chiffres = 42 caractères. La sortie ft_printf en contient 57 ! On y voit des zéros à la fois en place des espaces et en surplus : le test montre une ribambelle de 0 bien plus longue que prévu. Ce sur-remplissage se reproduit sur plusieurs cas (précision égale ou supérieure à la largeur, dans différentes bases) avec à chaque fois un écart de longueur correspondant aux zéros ajoutés deux fois.

Hypothèse sur la cause : Le code ne respecte pas la règle d’ignorance du flag 0 en présence d’une précision, et gère mal l’ordre des opérations. Il est probable que ft_printf :

Ne désactive pas le remplissage par '0' quand une précision est active – d’où l’utilisation de mauvais caractères (zéros au lieu d’espaces).

Calcule le padding de la largeur sans tenir compte que la précision a déjà éventuellement allongé le nombre. Par exemple, pour 42000 avec largeur 42 et précision 20, la fonction pourrait calculer “il manque 37 caractères pour la largeur” (42 – 5 digits) et mettre 37 zéros, puis appliquer la précision en ajoutant 15 zéros devant le nombre, aboutissant à 37+15 zéros au lieu de 22 espaces. En somme, le padding de largeur est calculé sur la longueur brute du nombre au lieu de la longueur finale formatée. La correction impliquera de : (a) ignorer le flag 0 dès qu’une précision numérique est spécifiée, et (b) calculer la largeur restante à remplir après avoir déterminé le nombre de chiffres (y compris ceux éventuellement ajoutés par la précision).

Erreurs de padding en alignement à gauche (-)

Comportement attendu : Avec le flag - (alignement à gauche), les espaces de remplissage doivent être ajoutés à droite du nombre jusqu’à atteindre la largeur demandée. La quantité d’espaces doit précisément combler la différence entre la largeur minimale et la longueur réelle du texte formaté. Par exemple, ft_printf("%-10.5d", 10) – 10 formaté sur 5 chiffres donne “00010” (longueur 5), puis 5 espaces à droite pour arriver à 10 caractères au total.

Comportement observé avec ft_printf : Le placement à gauche fonctionne, mais la quantité d’espaces est fréquemment fausse. Dans certains tests, ft_printf ajoute trop d’espaces : par exemple sur %-10.5u avec 10, la sortie attendue est [00010_____] (5 espaces, retour 10) mais on obtient [00010_________] avec 8 espaces, retour 13. Ici ft_printf a étendu la ligne au-delà de la largeur 10. D’autres fois, au contraire, il manque des espaces : un test %-10.u (valeur 0, largeur 10) attendu à 10 espaces a produit seulement 9 espaces. De façon générale, dès qu’une précision est combinée à l’alignement gauche, le calcul du padding semble erroné (voir aussi %-15.5i où 5 espaces attendus se transforment en 10 espaces dans la sortie).

Hypothèse sur la cause : Ces anomalies suggèrent que la longueur du contenu affiché n’est pas correctement prise en compte pour calculer les espaces à ajouter. Probablement, le programme calcule le nombre d’espaces avec la longueur du nombre non formaté au lieu de la longueur après formatage. Par exemple, dans le cas de %-10.5u avec 10, la valeur “10” fait 2 digits bruts, et ft_printf a peut-être fait 10 - 2 = 8 espaces, alors que le nombre formaté “00010” fait 5 caractères (il aurait fallu 10 - 5 = 5 espaces). De même, lorsqu’aucun caractère n’est finalement imprimé (ex : 0 avec précision 0), il devrait remplir entièrement la largeur d’espaces, mais on soupçonne qu’il réserve un emplacement pour un caractère inexistant, d’où un espace manquant. En résumé, la gestion de la largeur en mode aligné à gauche ne recalcule pas correctement la taille du texte final après application de la précision ou de la suppression du nombre, ce qui mène à ces décalages. Il faudra ajuster le calcul du padding droit pour qu’il utilise la longueur effective du segment déjà imprimé. (À noter que ces bugs d’espacement se manifestent dans tous les formats d’entiers, y compris en hexadécimal, de façon cohérente avec le même défaut de calcul.)
