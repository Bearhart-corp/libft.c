note après relecture:

il faut un fichier helper partagé entre les fonctions putnbr et uPutnbr

les 2 ont les mêmes besoin et il faut bien segmenter, de plus les codes sont beaucoup trop long..

Bug 7 – %p avec NULL et largeur : chaîne correcte mais valeur de retour fausse
Symptôme :
attendu : chaîne [the address is (nil)], len 23
obtenu : exactement la même chaîne, mais retour = 20
Bug 8 – %d / %i + largeur : \0 insérés dans le nombre lui-même

Bug 11 – Valeur de retour globalement incorrecte dès qu’il y a largeur / (nil) / padding


annexe: ft_printf.c :

# pour %x/%X : préfixe 0x/0X uniquement si la valeur ≠ 0.


Précision :

Un point '.' sans chiffre → précision 0
(sauf %f standard où l’absence de . implique 6, mais avec . seul c’est 0).

Pour les entiers, précision → nombre minimal de chiffres 
(zéros en tête), et annule l’effet de 0 (flag).

Cas spécial %.0d avec 0 → imprime rien (sauf si width → espaces uniquement).

Flags non arbitrés

+ vs espace : + prime sur espace.

- (alignement gauche) désactive 0.

# n’a pas d’effet sur %u/%d/%i/%s/%c.

%p ignore # (préfixe toujours).

Cas (nil)

%p avec NULL → imprime (nil) 
(sans 0x), gère la width autour de cette string, et compte correctement les bytes.

float

42 n’exige pas %f dans le sujet standard. Si tu le gardes :

Par défaut (pas de .), précision = 6.

Avec . seul → précision 0.

Attention aux arrondis et aux flags +, espace, -, 0.

print_fmt :

Le bloc if (conversion >= PTR && conversion <= HEX_MAJ) puis if (flags == HASH) écrit 0x avant de savoir
la valeur et avant de gérer width/precision → ça casse l’alignement et le comptage.
→ Calcule d’abord la représentation (avec/ sans préfixe), puis applique width/alignement une seule fois.

accuracyF :

Tu mets prec = 6 quand prec == 0. C’est faux pour %.0d et %.0s. Laisse 0.
La valeur “6 par défaut” ne s’applique qu’au cas sans . (et surtout au %f).

Pour les caractères “littéraux”, tu appelles ft_putchar_fd((*fmt), flags_struct); 
: attention si ta version de ft_putchar_fd lit des flags/width 
(elle ne devrait pas pour un char brut). Garde une version simple “write(1, &c, 1)”.

%p : ft_putnbr((long)va_arg(lst, void *), *flags_struct); est faux (type et base).
size_t	ft_putnbr(long n, t_flags f)
{
	size_t	count = 0;
	char	buf[64];
	int		base = 10;
	int		left = (f.flags & START_LEFT) != 0;
	int		zero_pad_width = (f.flags & ZEROS) && !left; /* (on ignore la précision ici) */
	const char *sign_str = "";

// DEPART 0 TROU DE BAL
	size_t	sign_len = 0;

	/* Sécurise le signe (évite les UB) */
    ok

	/* signe (+, ' ') seulement pour les signés et si pas négatif */
	if (neg) { sign_str = "-"; sign_len = 1; }
	else if (f.flags & PLUS) { sign_str = "+"; sign_len = 1; }
	else if (f.flags & SPACE) { sign_str = " "; sign_len = 1; }

	/* chiffres */
	size_t ndig = utoa_base(u, base, 0, buf);

	/* padding  */
	int pad; 
	if (zero_pad_width) {
		/* padding '0' → après le signe */
		int z = f.width - (int)(sign_len + ndig);
		if (z < 0) z = 0;
		/* alignement droit + '0' : signe, zéros, digits */
		if (!left) {
			count += putn(sign_str, sign_len);
			while (z--) count += putc('0');
			count += putn(buf, ndig);
			return count;
		}
		/* left + ZEROS: le flag '0' n'a pas d'effet si '-' → on tombe dans spaces à droite */
	}

	/* cas normal : espaces à gauche/droite */
	pad = f.width - (int)(sign_len + ndig);
	if (pad < 0) pad = 0;

	if (!left) while (pad--) count += putc(' ');
	count += putn(sign_str, sign_len);
	count += putn(buf, ndig);
	if (left)  while (pad--) count += putc(' ');
	return count;
}
et

static size_t print_nil_with_width(t_flags f)
{
	const char *nil = "(nil)";
	size_t L = 5, count = 0;
	int left = (f.flags & START_LEFT) != 0;
	int pad = f.width - (int)L; if (pad < 0) pad = 0;
	if (!left) while (pad--) count += putc(' ');
	count += putn(nil, L);
	if (left)  while (pad--) count += putc(' ');
	return count;
}

size_t	Uputnbr(unsigned long n, t_flags f)
{
	size_t	count = 0;
	char	buf[64];
	int		is_hex   = (f.conversion == HEX_LOW || f.conversion == HEX_MAJ || f.conversion == PTR);
	int		upper    = (f.conversion == HEX_MAJ);
	unsigned base    = is_hex ? 16 : 10;
	int		left     = (f.flags & START_LEFT) != 0;
	int		zero_pad_width = (f.flags & ZEROS) && !left; /* (sans précision ici) */

	/* %p: (nil) si 0 */
	if (f.conversion == PTR && n == 0)
		return print_nil_with_width(f);

	/* chiffres */
	size_t ndig = utoa_base((unsigned long long)n, base, upper, buf);

	/* préfixe ( %p → toujours "0x" ; %#x/#X → si n != 0 ) */
	const char *prefix = "";
	size_t pfx_len = 0;
	if (f.conversion == PTR) { prefix = "0x"; pfx_len = 2; }
	else if (is_hex && (f.flags & HASH) && n != 0) {
		prefix = upper ? "0X" : "0x"; pfx_len = 2;
	}

	/* + / ' ' : ignorés pour les *non signés* (on reste proche de printf) */
	const char *sign_str = "";
	size_t sign_len = 0;

	/* padding */
	if (zero_pad_width) {
		/* '0' de largeur → après signe et préfixe */
		int z = f.width - (int)(sign_len + pfx_len + ndig);
		if (z < 0) z = 0;
		if (!left) {
			count += putn(sign_str, sign_len);
			count += putn(prefix, pfx_len);
			while (z--) count += putc('0');
			count += putn(buf, ndig);
			return count;
		}
		/* avec '-' → pas d'effet de '0' → on retombe plus bas */
	}

	int pad = f.width - (int)(sign_len + pfx_len + ndig);
	if (pad < 0) pad = 0;

	if (!left) while (pad--) count += putc(' ');
	count += putn(sign_str, sign_len);
	count += putn(prefix, pfx_len);
	count += putn(buf, ndig);
	if (left)  while (pad--) count += putc(' ');
	return count;
}
PRECISION/
    size_t zeros = 0;
    if (f.has_prec) {
        if (f.prec == 0 && u == 0) ndig = 0;                /* %.0d et valeur 0 => rien */
        zeros = (f.prec > (int)ndig) ? (size_t)(f.prec - (int)ndig) : 0;
    }
EN PLUS

static size_t print_nil_with_width(t_flags f)
{
    const char *nil = "(nil)";
    size_t L = 5, count = 0;
    int left = (f.flags & START_LEFT) != 0;
    int pad = f.width - (int)L; if (pad < 0) pad = 0;
    if (!left) while (pad--) count += putc(' ');
    count += putn(nil, L);
    if (left)  while (pad--) count += putc(' ');
    return count;
}
