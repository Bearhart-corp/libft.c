note après relecture:

il faut un fichier helper partagé entre les fonctions putnbr et uPutnbr

les 2 ont les mêmes besoin et il faut bien segmenter, de plus les codes sont beaucoup trop long..

Bug 7 – %p avec NULL et largeur : chaîne correcte mais valeur de retour fausse
Symptôme :
attendu : chaîne [the address is (nil)], len 23
obtenu : exactement la même chaîne, mais retour = 20
Bug 8 – %d / %i + largeur : \0 insérés dans le nombre lui-même

Bug 11 – Valeur de retour globalement incorrecte dès qu’il y a largeur / (nil) / padding


annexe: ft_printf.c :

# pour %x/%X : préfixe 0x/0X uniquement si la valeur ≠ 0.


Précision :

Un point '.' sans chiffre → précision 0
(sauf %f standard où l’absence de . implique 6, mais avec . seul c’est 0).

Pour les entiers, précision → nombre minimal de chiffres 
(zéros en tête), et annule l’effet de 0 (flag).

Cas spécial %.0d avec 0 → imprime rien (sauf si width → espaces uniquement).

Flags non arbitrés

+ vs espace : + prime sur espace.

- (alignement gauche) désactive 0.

# n’a pas d’effet sur %u/%d/%i/%s/%c.

%p ignore # (préfixe toujours).

Cas (nil)

%p avec NULL → imprime (nil) 
(sans 0x), gère la width autour de cette string, et compte correctement les bytes.

float

42 n’exige pas %f dans le sujet standard. Si tu le gardes :

Par défaut (pas de .), précision = 6.

Avec . seul → précision 0.

Attention aux arrondis et aux flags +, espace, -, 0.

print_fmt :

Le bloc if (conversion >= PTR && conversion <= HEX_MAJ) puis if (flags == HASH) écrit 0x avant de savoir
la valeur et avant de gérer width/precision → ça casse l’alignement et le comptage.
→ Calcule d’abord la représentation (avec/ sans préfixe), puis applique width/alignement une seule fois.

accuracyF :

Tu mets prec = 6 quand prec == 0. C’est faux pour %.0d et %.0s. Laisse 0.
La valeur “6 par défaut” ne s’applique qu’au cas sans . (et surtout au %f).

Pour les caractères “littéraux”, tu appelles ft_putchar_fd((*fmt), flags_struct); 
: attention si ta version de ft_putchar_fd lit des flags/width 
(elle ne devrait pas pour un char brut). Garde une version simple “write(1, &c, 1)”.
