Bug 1 – %p sans le préfixe 0x
Bug 2 – %p avec (void *)-1 affiché en -1 au lieu de 0xffffffffffffffff
tu dois toujours caster le void * en type non signé et jamais laisser la représentation
signée intervenir.
Bug 3 – Padding de largeur rempli avec des \0 au lieu d’espaces ' '
Bug 4 – Largeur (width) qui boucle à l’infini → TIMEOUT sur %s et %p
Origine probable (très classique) :

Tu calcules pad = width - len dans un type non signé (size_t, unsigned int, etc.).

Quand len > width, width - len underflow → énorme nombre positif →
ta boucle de padding (while (pad--)) ne finit jamais.
int pad = width - len;
if (pad < 0)
    pad = 0;
Ou tester explicitement if (width > len) avant de boucler.
Bug 5 – %s + largeur mal géré pour les NULL ((null))
Origine probable :
Tu traites le cas s == NULL en remplaçant par la chaîne (null)
mais tu ne recalcules pas correctement la longueur
quand tu appliques la largeur.
Bug 6 – %p + largeur : mélange de deux bugs (0x manquant + padding en \0)
Le 0x n’est jamais géré comme partie de la string à aligner/padder ;
du coup même quand tu le rajouteras, il faudra le compter dans la longueur
avant de calculer les espaces.
Bug 7 – %p avec NULL et largeur : chaîne correcte mais valeur de retour fausse
Symptôme :
attendu : chaîne [the address is (nil)], len 23
obtenu : exactement la même chaîne, mais retour = 20
Bug 8 – %d / %i + largeur : \0 insérés dans le nombre lui-même
Bug 9 – %d / %i avec INT_MIN mal géré (overflow sur -n)
Pour les 0 a tous les coups j'ai dû confondre 0 avec '0' #chevre

Bug 10 – %d / %i / %p + largeur : TIMEOUT sur certains cas extrêmes
pad = width - len dans un type non signé → underflow → boucle infinie.

Bug 11 – Valeur de retour globalement incorrecte dès qu’il y a largeur / (nil) / padding


annexe: ft_printf.c :
%p doit toujours afficher 0x (sauf (nil) pour NULL) et utiliser base 16 minuscule.
Le préfixe ne dépend pas de #.

# pour %x/%X : préfixe 0x/0X uniquement si la valeur ≠ 0.
%p : tu fais va_arg(lst, void*) puis (long).
Il faut toujours caster vers un entier non signé de largeur pointeur, idéalement uintptr_t.
→ uintptr_t addr = (uintptr_t)va_arg(lst, void *);

 Mieux : une fonction dédiée print_uint_base(value, base, upper)
qui retourne le nombre de bytes écrits, et gère proprement le préfixe via les flags.

ZEROS vs START_LEFT : if ((flags & START_LEFT) != 1)
est faux pour un masque de bits. Il faut tester if (!(flags & START_LEFT))....

Précision :

Un point '.' sans chiffre → précision 0
(sauf %f standard où l’absence de . implique 6, mais avec . seul c’est 0).

Pour %s, précision = max de caractères à imprimer.

Pour les entiers, précision → nombre minimal de chiffres 
(zéros en tête), et annule l’effet de 0 (flag).

Cas spécial %.0d avec 0 → imprime rien (sauf si width → espaces uniquement).

Dans conv, tu fais exceptionnellement (*fmt)++ pour 'f' seulement : incohérent.
Stratégie saine : toujours consommer le spécificateur dans conv après l’avoir reconnu,
puis appeler print_fmt.

Flags non arbitrés

+ vs espace : + prime sur espace.

- (alignement gauche) désactive 0.

# n’a pas d’effet sur %u/%d/%i/%s/%c.

%p ignore # (préfixe toujours).

Cas (nil)

%p avec NULL → imprime (nil) 
(sans 0x), gère la width autour de cette string, et compte correctement les bytes.

float

42 n’exige pas %f dans le sujet standard. Si tu le gardes :

Par défaut (pas de .), précision = 6.

Avec . seul → précision 0.

Attention aux arrondis et aux flags +, espace, -, 0.

print_fmt :

Le bloc if (conversion >= PTR && conversion <= HEX_MAJ) puis if (flags == HASH) écrit 0x avant de savoir
la valeur et avant de gérer width/precision → ça casse l’alignement et le comptage.
→ Calcule d’abord la représentation (avec/ sans préfixe), puis applique width/alignement une seule fois.

accuracyF :

Tu mets prec = 6 quand prec == 0. C’est faux pour %.0d et %.0s. Laisse 0.
La valeur “6 par défaut” ne s’applique qu’au cas sans . (et surtout au %f).

Pour les caractères “littéraux”, tu appelles ft_putchar_fd((*fmt), flags_struct); 
: attention si ta version de ft_putchar_fd lit des flags/width 
(elle ne devrait pas pour un char brut). Garde une version simple “write(1, &c, 1)”.

%p : ft_putnbr((long)va_arg(lst, void *), *flags_struct); est faux (type et base).

putstr tah les ptits oignons:
size_t  ft_putstr_fd(char *s, t_flags f)
{
    size_t  count;
    size_t  len;
    size_t  display_len;
    size_t  pad;
    char    padc;

    count = 0;
    padc = ' ';                         // jamais '0' pour %s
    if (!s)
        s = "(null)";

    len = ft_strlen(s);

    if (f.has_prec)                     // précision s'applique à %s
        display_len = (f.prec < (int)len) ? (size_t)f.prec : len;
    else
        display_len = len;

    // largeur : espaces autour selon l'alignement
    pad = (f.width > (int)display_len) ? (size_t)(f.width - (int)display_len) : 0;

    if (!(f.flags & START_LEFT))        // alignement droit
        while (pad--) count += write(1, &padc, 1);

    // imprimer exactement display_len chars
    count += write(1, s, display_len);

    if (f.flags & START_LEFT)           // alignement gauche
        while (pad--) count += write(1, &padc, 1);

    return count;
}


putnbr...

#include <stdint.h>
#include <unistd.h>

static size_t  putn(const char *s, size_t n) { return write(1, s, n); }
static size_t  putc(char c) { return write(1, &c, 1); }

static int to_digit(int v, int upper) {
    char c = "0123456789abcdef"[v & 15];
    return upper ? (int)((c >= 'a' && c <= 'f') ? (c - 32) : c) : (int)c;
}

static size_t utoa_base(unsigned long long u, int base, int upper, char *buf) {
    // Retourne la longueur et écrit les digits en ordre normal dans buf
    char tmp[64];
    size_t k = 0;
    if (u == 0) tmp[k++] = '0';
    while (u) { tmp[k++] = (char)to_digit((int)(u % base), upper); u /= base; }
    // reverse -> buf
    for (size_t i = 0; i < k; ++i) buf[i] = tmp[k - 1 - i];
    return k;
}

size_t  ft_putnbr(long n_signed, t_flags f)
{
    // Détermine le type demandé via f.conversion
    int conv = f.conversion;
    int is_signed = (conv == INTEGER);              // %d/%i
    int is_hex    = (conv == HEX_LOW || conv == HEX_MAJ);
    int upper     = (conv == HEX_MAJ);
    int base      = is_hex ? 16 : 10;

    // Gestion %p (chaîne "(nil)" avec width/align si NULL)
    if (conv == PTR) {
        uintptr_t p = (uintptr_t)(void *)n_signed;  // n_signed contient arg brut chez toi, adapte l'appel
        if (p == 0) {
            // width autour de "(nil)"
            const char *nil = "(nil)";
            size_t L = 5, count = 0;
            int pad = (f.width > (int)L) ? (f.width - (int)L) : 0;
            if (!(f.flags & START_LEFT)) while (pad--) count += putc(' ');
            count += putn(nil, L);
            if  ( f.flags & START_LEFT ) while (pad--) count += putc(' ');
            return count;
        }
        // basculer dans flux “entier non signé + préfixe 0x”
        is_signed = 0; base = 16; upper = 0;
        // on glisse la valeur dans un “u”
        unsigned long long u = (unsigned long long)p;

        // construire les morceaux
        char digits[64]; size_t ndig = utoa_base(u, base, upper, digits);
        size_t sign_len = 0;                // jamais de signe pour %p
        const char *prefix = "0x"; size_t prefix_len = 2;

        // précision pour hex: zéros en tête
        size_t zeros = 0;
        if (f.has_prec) zeros = (f.prec > (int)ndig) ? (size_t)(f.prec - (int)ndig) : 0;

        // règle du flag '0'
        int zero_width = (!f.has_prec && (f.flags & ZEROS) && !(f.flags & START_LEFT));

        size_t core = sign_len + prefix_len + (zeros + ndig);
        size_t count = 0;

        if (zero_width) {
            int z = (f.width > (int)core) ? (f.width - (int)core) : 0;
            // 0-padding de largeur va *entre* prefix et digits (après prefix)
            count += putn(prefix, prefix_len);
            while (z--) count += putc('0');
            while (zeros--) count += putc('0');
            count += putn(digits, ndig);
            return count;
        } else {
            int pad = (f.width > (int)core) ? (f.width - (int)core) : 0;
            if (!(f.flags & START_LEFT)) while (pad--) count += putc(' ');
            count += putn(prefix, prefix_len);
            while (zeros--) count += putc('0');
            count += putn(digits, ndig);
            if  ( f.flags & START_LEFT ) while (pad--) count += putc(' ');
            return count;
        }
    }

    // Récupération valeur en fonction du format
    unsigned long long u;
    int neg = 0;
    if (is_signed) {
        long long v = (long long)n_signed;         // chez toi tu passais un int casté en long → cast large ici
        if (v < 0) { neg = 1; u = (unsigned long long)(-v); }
        else u = (unsigned long long)v;
    } else if (is_hex) {
        unsigned int v = (unsigned int)n_signed;
        u = (unsigned long long)v;
    } else { // %u
        unsigned int v = (unsigned int)n_signed;
        u = (unsigned long long)v;
    }

    // Cas spécial précision=0 et valeur=0 -> pas de digits
    char digits[64];
    size_t ndig = (f.has_prec && f.prec == 0 && u == 0) ? 0 : utoa_base(u, base, upper, digits);

    // Signes et préfixes
    const char *sign = "";
    size_t sign_len = 0;
    if (is_signed) {
        if (neg) { sign = "-"; sign_len = 1; }
        else if (f.flags & PLUS) { sign = "+"; sign_len = 1; }
        else if (f.flags & SPACE) { sign = " "; sign_len = 1; }
    }
    const char *prefix = "";
    size_t prefix_len = 0;
    if (is_hex && (f.flags & HASH) && u != 0) {
        prefix = upper ? "0X" : "0x";
        prefix_len = 2;
    }

    // Zéros de précision
    size_t zeros = 0;
    if (f.has_prec) zeros = (f.prec > (int)ndig) ? (size_t)(f.prec - (int)ndig) : 0;

    // Choix padding de largeur en '0' seulement si pas de précision & pas d'alignement gauche
    int zero_width = (!f.has_prec && (f.flags & ZEROS) && !(f.flags & START_LEFT));

    size_t core = sign_len + prefix_len + (zeros + ndig);
    size_t count = 0;

    if (zero_width) {
        // padding '0' de largeur se place après signe et préfixe
        int z = (f.width > (int)core) ? (f.width - (int)core) : 0;
        count += putn(sign, sign_len);
        count += putn(prefix, prefix_len);
        while (z--) count += putc('0');
        while (zeros--) count += putc('0');
        if (ndig) count += putn(digits, ndig);
        return count;
    } else {
        int pad = (f.width > (int)core) ? (f.width - (int)core) : 0;
        if (!(f.flags & START_LEFT)) while (pad--) count += putc(' ');
        count += putn(sign, sign_len);
        count += putn(prefix, prefix_len);
        while (zeros--) count += putc('0');
        if (ndig) count += putn(digits, ndig);
        if  ( f.flags & START_LEFT ) while (pad--) count += putc(' ');
        return count;
    }
}
