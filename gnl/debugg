Init stricte : vérifier que fd est valide, que BUFFER_SIZE > 0, et que read(fd, "", 0) ne renvoie pas -1
Avoir une seule variable static : static t_buf_state *lst; (tête de liste).

Parcourir la liste chaînée g_list pour trouver le nœud dont t_buf_state->fd == fd.
Si aucun contexte n’existe pour ce fd :
malloc un nouveau t_buf_state,

Chercher un \n dans t_buf_state->stash.

Si trouvé :

copier les caractères dans line, mettre '\0'
décaler le reste de la stash en début de buffer (memmove) comme azur mais faire gaf si le reste est rempli de 0 ou pas, on peut aussi juste null terminate
retourner line immédiatement

Déclarer un char buf[BUFFER_SIZE]; local.
Déclarer ssize_t n.

Boucler tant qu’aucune ligne complète n’a été trouvée :
n = read(fd, buf, BUFFER_SIZE);

Cas d’erreur / EOF

Si n < 0 (erreur I/O) :
libérer t_buf_state->stash si non NULL
sortir ce t_buf_state de la liste chaînée
free le t_buf_state
return NULL
Si n == 0 (EOF atteint) :
sortir de la boucle (on gère la stash après)

Ajout à la stash

Si n > 0 :
si t_buf_state->len + n > t_buf_state->cap :
si t_buf_state->cap == 0, cap = n;
doubler t_buf_state->cap jusqu’à ce que cap >= t_buf_state->len + n
realloc la stash avec cap + 1 octets
copier les n octets de buf à la suite de t_buf_state->stash (mem copy avec un dest a stash + len, buffersize pour les nbytes)
mettre à jour t_buf_state->len += n
t_buf_state->stash[t_buf_state->len] = '\0'

Recherche d’un \n après ajout

Ré-examiner t_buf_state->stash pour un \n.
Si trouvé → extraire la ligne et retourner la ligne.

6. EOF sans \n (fin de fichier réelle)

Si on sort de la boucle car n == 0 : ( apres un read )
Si t_buf_state->len == 0 (stash vide) :
libérer t_buf_state->stash si besoin
retirer le t_buf_state de la liste
free le t_buf_state
return NULL // car si stash vide on a 0 char et donc on renvoie NULL 
Sinon (stash non vide → dernière ligne sans \n) :
allouer line de taille t_buf_state->len + 1
copier toute la stash
line[t_buf_state->len] = '\0'
libérer t_buf_state->stash
retirer le t_buf_state de la liste
free le t_buf_state
retourner la dernière ligne

si stash != NULL → on doit la free AVANT de free(buf_state)

EXEMPLE IMPORTANT

AAAA\nBBBB\nCCCC
Scénario :

Tu lis AAAA\nBB → tu rends AAAA\n →
stash = "BB" (reste après le \n).

Tu relis encore → tu rajoutes à la stash →
stash devient "BBBB\nCCCC"
→ tu rends BBBB\n
→ stash = "CCCC".

Tant qu’il y a \n, tu continues ce jeu “ligne rendue / reste dans stash”.

Ici, stash ≠ "ligne entière".
C’est juste le buffer-tampon de ce qui dépasse la dernière ligne rendue.

